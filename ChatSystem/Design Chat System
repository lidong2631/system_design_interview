Design Chat System

jiuzhang
---------- final solution:
Service
1. Message service 		2. Push service 	3. Channel Service

Storage
3 tables:
message table - store message info
thread table - store public thread info and participants (who is in this thread)
userThread table - store private thread info for each user

User Thread Table 															Thread Table 														Message Table
id 							primary key 	bigint 							id 						primary key 	bigint 						id 					int
user_id 					foreign key 									last_message 			text 										thread_id 			int
thread_id 					foreign key 									avatar 					varchar 									user_id 			int 			谁发的
unread_count 				int 											created_at 				timestamp 									content 			text 			发了啥
is_muted 					boolean 										participants_hash_code 	varchar 									created_at 			timestamp 		啥时候发的
updated_at 					timestamp 		什么时候更新
joined_at 					timestamp 		什么时候加入对话

取某个 Thread 下的所有 Message
SELECT * FROM message_table
WHERE thread_id=12345 —— 筛选属于某个 Thread 的信息 ORDER BY created_at DESC —— 按照时间倒序排列
LIMIT 20 —— 取最近20条

Message Table (Nosql) - 数据量很大，不需要修改，一条聊天信息就像一条log一样 	row_key = thread_id 	column_key = created_at 因为要按照时间倒序 • value = 其他信息
Thread Table (SQL/NoSQL) - Thread Table 存储公有的 Thread 信息 	如果使用 SQL 需要同时 index by 1. thread_id用于查询某个对话的信息 	2. participant_hash_code用户查询某些用户之间是否已经有thread
																如果使用 NoSQL 存储 Thread Table 并同时支持按照 thread_id 和participant_hash_code 进行查询，我们需要两张表:
																• 表1:Thread Table 	• row_key = thread_id 	• column_key = null 	• value = 其他的基本信息
																• 表2:ParticipantHashCode Table 	• row_key = participant_hash_code 	• column_key = null 	• value = thread_id
UserThread Table (NoSQL) - UserThread Table 存储私有的 Thread 信息 	• row_key = user_id 	• column_key = updated_at 按照更新时间倒序
一个可行解的流程
1. 用户A打开App后，问 Web Server 要一个 Push Service (use Socket) 的连接地址 
2. A通过 socket 与push server保持连接
3. 用户B发消息给A，消息先被发送到服务器
4. 服务器收到消息，查询是否有 A 和 B 的对话记录(Thread)，如果没有则创建对应的 Thread
5. 根据 Thread id 创建 Message
6. 服务器把消息存储之后，告诉 Push Server 让他通知 A
7. A 收到及时的消息提醒
8. if push server is down client can fall back to poll every 10s from web server (message service)

GroupChat
增加一个Channel Service(频道服务) 对于较大群 为每个聊天的Thread增加一个Channel信息 
1. 用户上线时，Web Server (message service) 找到用户所属的频道(群)，并通知 Channel Service 完成订阅 Channel就知道哪些频道里有哪些用户还活着
2. 用户如果断线了，Push Service 会知道用户掉线了，通知 Channel Service 从所属的频道里移除
3. Message Service 收到用户发的信息之后  根据thread id找到对应的channel
4. 把发消息的请求发送给 Channel Service  原来发500条消息变成发1条消息
5. Channel Service 找到当前在线的用户
6. 然后发给 Push Service 把消息 Push 出去
本质利用了订阅和push service

Q: Channel Service 中的数据是什么结构?
A: key-value 的结构。key 为 channel name，可以是一个字符串比如 “#personal::user_1”。value是一个set 代表哪些人订阅到了这个 channel 下。
Q: Channel Service 用什么数据存储?
A: 根据上面所提到的 key-value 结构以及 value 需要是一个 set，Redis 是一个很好的选择。 
Q: 如何知道一个用户该订阅到哪些 Channels?
A: 首先用户需要订阅自己的 personal channel，如 #personal::user_1，与该用户有关的私聊信息都在这 个 channel 里发送。小于一定人数的群聊可以依然通过 personal channel 推送，超过一定人数的群聊， 可以采用 lazy subscribe 的方式，在用户打开 APP 且群处于比较靠前的位置的时候才订阅，用户没有主 动订阅的群聊靠 Poll 的模式获取最新消息。

拓展问题1:多机登录 multiple session
在 session 中记录用户的客户端信息
用户尝试从新的客户端登录时 如从手机登陆时，查询是否已经有其他手机处于登陆状态 如果没有，则创建新的 session 如果有，将对应的 session 设为 expire 或者删除，并发送 push notification 让已经登录的手机 logout

拓展问题2:如何支持用户在线状态显示? Pull (heartbeat)
使用数据库存储 online status 的信息 <user, last_updated_at, client_info>
----------






Alex Xu Chapter 12 Design a chat system

Candidate: What kind of chat app shall we design? 1 on 1 or group based? 
Interviewer: It should support both 1 on 1 and group chat.

Candidate: Is this a mobile app? Or a web app? Or both? 
Interviewer: Both.

Candidate: What is the scale of this app? A startup app or massive scale? 
Interviewer: It should support 50 million daily active users (DAU).

Candidate: For group chat, what is the group member limit? 
Interviewer: A maximum of 100 people

Candidate: What features are important for the chat app? Can it support attachment? 
Interviewer: 1 on 1 chat, group chat, online indicator. The system only supports text messages.

Candidate: Is there a message size limit?
Interviewer: Yes, text length should be less than 100,000 characters long.

Candidate: Is end-to-end encryption required?
Interviewer: Not required for now but we will discuss that if time allows.

Candidate: How long shall we store the chat history? 
Interviewer: Forever.


high level design
client use http protocol
server use polling, long polling, websocket

Long polling has a few drawbacks:
• Sender and receiver may not connect to the same chat server. HTTP based servers are usually stateless. If you use round robin for load balancing, the server that receives the message might not have 
	a long-polling connection with the client who receives the message.
• A server has no good way to tell if a client is disconnected.
• It is inefficient. If a user does not chat much, long polling still makes periodic connections after timeouts.

Websocket
WebSocket connection is initiated by the client. It is bi-directional and persistent. It starts its life as a HTTP connection and could be “upgraded” via some well-defined handshake to a WebSocket connection. 
Through this persistent connection, a server could send updates to a client

the client maintains a persistent WebSocket connection to a chat server for real-time messaging.
• Chat servers facilitate message sending/receiving.
• Presence servers manage online/offline status.
• API servers handle everything including user login, signup, change profile, etc.
• Notification servers send push notifications.
• Finally, the key-value store is used to store chat history. When an offline user comes online, she will see all her previous chat history.

Storage
relational databases or NoSQL databases ?
Two types of data exist in a typical chat system. The first is generic data, such as user profile, setting, user friends list. These data are stored in robust and reliable relational databases. 
Replication and sharding are common techniques to satisfy availability and scalability requirements.

The second is unique to chat systems: chat history data
• The amount of data is enormous for chat systems. A previous study [2] reveals that Facebook messenger and Whatsapp process 60 billion messages a day.
• Only recent chats are accessed frequently. Users do not usually look up for old chats.
• Although very recent chat history is viewed in most cases, users might use features that require random access of data, such as search, view your mentions, jump to specific messages, etc. These cases should be supported by the data access layer.
• The read to write ratio is about 1:1 for 1 on 1 chat apps.

We recommend key-value stores for the following reasons:
• Key-value stores allow easy horizontal scaling.
• Key-value stores provide very low latency to access data.
• Relational databases do not handle long tail [3] of data well. When the indexes grow large, random access is expensive.
• Key-value stores are adopted by other proven reliable chat applications. For example, both Facebook messenger and Discord use key-value stores. Facebook messenger uses HBase [4], and Discord uses Cassandra [5].

Data Models
message 										group_message
message_id  	bigint 							channel_id 		bigint
message_from 	bigint 							message_id 		bigint
message_to 		bigint 							user_id 		bigint
content 		text 							content 		text
created_at 		timestamp 						created_at  	timestamp


deep dive
Service discovery
The primary role of service discovery is to recommend the best chat server for a client based on the criteria like geographical location, server capacity,
1. User A tries to log in to the app.
2. The load balancer sends the login request to API servers.
3. After the backend authenticates the user, service discovery finds the best chat server for User A. In this example, server 2 is chosen and the server info is returned back to User A.
4. User A connects to chat server 2 through WebSocket.

Message flows
1 on 1 chat flow
1. User A sends a chat message to Chat server 1.
2. Chat server 1 obtains a message ID from the ID generator.
3. Chat server 1 sends the message to the message sync queue.
4. The message is stored in a key-value store.
5.a. If User B is online, the message is forwarded to Chat server 2 where User B is connected.
5.b. If User B is offline, a push notification is sent from push notification (PN) servers.
6. Chat server 2 forwards the message to User B. There is a persistent WebSocket connection between User B and Chat server 2.

Message synchronization across multiple devices
Each device maintains a variable called cur_max_message_id, which keeps track of the latest message ID on the device. Messages that satisfy the following two conditions are considered as news messages:
• The recipient ID is equal to the currently logged-in user ID.
• Message ID in the key-value store is larger than cur_max_message_id .
With distinct cur_max_message_id on each device, message synchronization is easy as each device can get new messages from the KV store.

Small group chat flow
Assume there are 3 members in the group (User A, User B and user C). First, the message from User A is copied to each group member’s message sync queue: one for User B and the second for User C. 
You can think of the message sync queue as an inbox for a recipien

Online presence
user login
user logout
user disconnection
online statua fanout




























