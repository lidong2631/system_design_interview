Design Chat System (slack, discord, whatsapp)

InfoQ How Slack Works
https://www.youtube.com/watch?v=WE9c9AZe-DY

Scott shi
https://www.youtube.com/watch?v=-UXWETzHG38

IM消息ID技术专题(一)：微信的海量IM聊天消息序列号生成实践（算法原理篇)
http://www.52im.net/thread-1998-1-1.html



broadcast in group chat is similar to fanout in newsfeed (push vs pull)


how to generate message id ? (need to be unique and monotonically increasing within one channel or private chat)
融云消息id的设计 80bits total. 64bit : 时间戳 42bit | 自旋ID 12bit | 会话类型4bit | 会话ID高位6bit 16bit：会话ID低位
https://blog.csdn.net/liaya1/article/details/126426629?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-126426629-blog-108218729.pc_relevant_multi_platform_whitelistv4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-126426629-blog-108218729.pc_relevant_multi_platform_whitelistv4&utm_relevant_index=12



from zixuan zhang
https://towardsdatascience.com/ace-the-system-interview-design-a-chat-application-3f34fd5b85d0

Requirements
Direct messaging: two users can chat with each other
Group chat: users can participate in group conversations
Join/leave groups, (add/delete friends not important for Slack)
Typing indicator: when typing, the recipient gets notified
User status: whether you are online or offline
When the user is offline, try send notifications to the user’s mobile device if a new message arrives.

Given user A and user B, retrieve messages after a certain timestamp
Given group G, retrieve all messages after a certain timestamp
Given group G, find all member ID
Given user A, find all groups he/she joined

Save a message between user A and user B
Save a new message by user A in group G
Add/delete user A to/from group G



DB
database is used primarily as a key-value store. No complex relational ops such as join are needed. must be horizontally scalable and tuned for writes.
cassandra or redis should do it

schema
see images

note: it might be better to use hash(user_id_1:user_id_2) as thread_id for the partition key so api call can just use the hash

private chat table
user id 1  |  user id 2  |  message id  |  timestamp  |  message
  A 					B 		
----- partition key	-----|--- sort key--|		

note: it might be better to use hash(user_id_1:user_id_2:...) for the partition key so api call can just use the hash

group chat table
group id  							 |  message id  |  timestamp  |  message  |  user id
----- partition key	-----|--- sort key--|


message ID is used to determine the ordering (sorted by timestamp). The message Id is not globally unique, as its scope is determined by the partition key. 
The system will never retrieve an item by its message ID alone. (twitter snowflake id)

group member table
group id  							 |  user id
----- partition key	-----|--- sort key--|

user member table
user id  								 |  group id
----- partition key	-----|--- sort key--|

group membership / user membership
The Group Membership table is used for message broadcasting — we need to figure out who gets the message. The User Membership table is for listing all the groups a user has joined. 
We could use a single table with a secondary index, but the cardinality of group ID/user ID is too large for a secondary index. The two-table approach isn’t without problems either
if we mutate one, the other should be modified to maintain consistency, which requires distributed transactions.

user profile table
user id  |  password  |  status  | profile pic url
partition key



api design

api-key
https://swagger.io/docs/specification/authentication/api-keys/

bearer token
The bearer token is a cryptic string, usually generated by the server in response to a login request. The client must send this token in the Authorization header when making requests to protected resources:
https://swagger.io/docs/specification/authentication/bearer-authentication/

path parameters vs query parameters vs header parameters vs cookie parameters
https://swagger.io/docs/specification/describing-parameters/#:~:text=Path%20parameters%20are%20variable%20parts,denoted%20with%20curly%20braces%20%7B%20%7D%20.

line api doc
https://developers.line.biz/en/reference/messaging-api/#send-narrowcast-message

send a message
POST /api/v1/message
{
		'user_id':
		'receiver_id':  user id / group id
		'channel_type': private / group
		'content':
}

private chat
GET /api/v1/thread/{thread_id}/message?max_message_id={max_message_id}
group chat
GET /api/v1/group/{group_id}/message?max_message_id={max_message_id}

leave a group
POST https://api.line.me/v2/bot/group/{groupId}/leave

rpc
send_message(user_id, receiver_id, channel_type, message) 				 		// The channel_type field is used to distinguish private chats from group chats.
get_messages(user_id, user_id2, channel_type, earliest_message_id) 		// The receiver_id /user_id2 can be a user ID or a group ID.
join_group(user_id, group_id) 																				// The earliest_message_id is the latest message locally available on the client. It is used as the sort key to range query the chat tables.
leave_group(user_id, group_id)
get_all_group(user_id)
// ignore RPC for login/logout, ignore authentication token 



architecture
-- Chat Service: each online user maintains a WebSocket connection with a WebSocket server in the Chat Service. Outgoing and incoming chat messages are exchanged here.

-- Web Service: It handles all RPC calls except send_message(). Users talk to this service for authentication, join/leave groups, etc. No WebSocket is needed here since all calls are client-initiated and HTTP-based.

-- Notification Service: When the user is offline, messages are pushed to external phone manufacturers’ notification servers (e.g. Apple’s )
	* we might not need the notifications services. when user is offline we'll just store the message in db. we don't have to deliver to receiver. 
		when the user is online he'll poll from db for history catch up
  	the application need to write the last_message_id into local disk for the user so when he's online it knows what's the new message he misses

-- Presence Service: When a user is typing or changes status, the Presence Service is responsible for figuring out who gets the push update.

-- User Mapping Service: Our chat service is globally distributed. We need to keep track of the server ID of the user’s session host.

-- * group service servers(shard by group id) (note if we want to make sure all message order within a group chat we might need group service so all websocket server send msg to group service and group service will generate
  	sequence and all message within a group is ordered)
  	group service servers can also poll user profile table regularly so it knows which use is online and only forward msg to online user for group chat message or alternatively, user can send heartbeat to group service
  	regularly and group servers can hold the online status in memory so it does not need to poll from db



dataflow
normal message delivery
failed message delivery
history catch up
presence detection



presence service
client sends a heartbeat event to the server every 5 seconds. After sending 3 heartbeat events, the client is disconnected and does not reconnect within x = 30 seconds (
This number is arbitrarily chosen to demonstrate the logic). The online status is changed to offline.
Online status fanout for smaller group ppl
bigger group can use poll or fetch online status only when a user enters a group or manually refreshes the friend list




questions might be asked
1. The first issue is how web socket servers communicate with each other (step 5 in figure 6). How websocket send message to each other ?
	we can use sync http cal. 
	issues:
	1. No message order 	(rely on local sequence)
		To solve the ordering issue, we can annotate every message with a prevMsgID field. The recipient checks his local log and initiates history catch-ups when an inconsistency is found.
		
		private chat
		常见优化方案，在A往B发出的消息中，加上发送方A本地的一个绝对时序（比如本机时间戳），来表示接收方B的展现时序。
		那么当接收方B收到消息后，即使极端情况下消息可能存在乱序到达，但因为这个乱序的时间差对于普通用户来说体感是很短的，在UI展现层按照消息中自带的绝对时序排个序后再显示，用户其实是没有太多感知的。
		group chat
		在service连接池层面做细小的改造，保证一个群的消息落在同一个service上，这个service就可以用本地seq来序列化同一个群的所有消息，保证所有群友看到消息的时序是相同的。
		https://segmentfault.com/a/1190000037720265
	2. send each message in separate call is expensive (implement buffering algorithm on WebSocket servers send accumulated messages, say, ~50 MS with randomized offsets (preventing everyone from sending messages at the same time)

2. Handling Group Chat (1. enforce limit for group say max 500 ppl only send msg to online user.)
write amplication vs read amplication
For smaller groups or inactive groups, it is okay to do pushing since write amplification won’t stress out the servers. For very active and large groups, clients must query the HTTP server regularly for messages.

3. batch writing
When a message is received by a web socket server, it is persisted into the database. The simplest approach would be calling the database directly. With this implementation, the database is bombarded with ~100K RPS traffic
use queues for batch insertion. When the queue service receives a write, the web socket server, in turn, acknowledges the client. At the other end of the queue, 
a dedicated batch writer can group hundreds of messages into a single request

4. clock synchronization in network
	1. use network time protocol NTP (help in certain extent)
	2. logical clocks, which are based on incrementing counters rather than an oscillating quartz crystal, are safer alternative for ordering events. it doesn't measure the time of day or number of seconds elapsed,
	only the relative ordering of events
	n logical clock systems each process has two data structures: logical local time and logical global time. Logical local time is used by the process to mark its own events, and logical global time is the local information about global time. A special protocol is used to update logical local time after each local event, and logical global time when processes exchange data.
	https://www.geeksforgeeks.org/logical-clock-in-distributed-system/
	lamport clock, vector lock

5. sync up message on different device
Each device maintains a variable called cur_max_message_id, which keeps track of the latest message ID on the device. Messages that satisfy the following two conditions are considered as news messages:
• The recipient ID is equal to the currently logged-in user ID.
• Message ID in the key-value store is larger than cur_max_message_id .
With distinct cur_max_message_id on each device, message synchronization is easy as each device can get new messages from the KV store.








jiuzhang
---------- final solution:
Service
1. Message service 		2. Push service 	3. Channel Service

Storage
3 tables:
message table - store message info
thread table - store public thread info and participants (who is in this thread)
userThread table - store private thread info for each user

User Thread Table 															Thread Table 														Message Table
id 							primary key 	bigint 							id 						primary key 	bigint 						id 					int
user_id 					foreign key 									last_message 			text 										thread_id 			int
thread_id 					foreign key 									avatar 					varchar 									user_id 			int 			谁发的
unread_count 				int 											created_at 				timestamp 									content 			text 			发了啥
is_muted 					boolean 										participants_hash_code 	varchar 									created_at 			timestamp 		啥时候发的
updated_at 					timestamp 		什么时候更新
joined_at 					timestamp 		什么时候加入对话

取某个 Thread 下的所有 Message
SELECT * FROM message_table
WHERE thread_id=12345 —— 筛选属于某个 Thread 的信息 ORDER BY created_at DESC —— 按照时间倒序排列
LIMIT 20 —— 取最近20条

Message Table (Nosql) - 数据量很大，不需要修改，一条聊天信息就像一条log一样 	row_key = thread_id 	column_key = created_at 因为要按照时间倒序 • value = 其他信息
Thread Table (SQL/NoSQL) - Thread Table 存储公有的 Thread 信息 	如果使用 SQL 需要同时 index by 1. thread_id用于查询某个对话的信息 	2. participant_hash_code用户查询某些用户之间是否已经有thread
																如果使用 NoSQL 存储 Thread Table 并同时支持按照 thread_id 和participant_hash_code 进行查询，我们需要两张表:
																• 表1:Thread Table 	• row_key = thread_id 	• column_key = null 	• value = 其他的基本信息
																• 表2:ParticipantHashCode Table 	• row_key = participant_hash_code 	• column_key = null 	• value = thread_id
UserThread Table (NoSQL) - UserThread Table 存储私有的 Thread 信息 	• row_key = user_id 	• column_key = updated_at 按照更新时间倒序
一个可行解的流程
1. 用户A打开App后，问 Web Server 要一个 Push Service (use Socket) 的连接地址 
2. A通过 socket 与push server保持连接
3. 用户B发消息给A，消息先被发送到服务器
4. 服务器收到消息，查询是否有 A 和 B 的对话记录(Thread)，如果没有则创建对应的 Thread
5. 根据 Thread id 创建 Message
6. 服务器把消息存储之后，告诉 Push Server 让他通知 A
7. A 收到及时的消息提醒
8. if push server is down client can fall back to poll every 10s from web server (message service)

GroupChat
增加一个Channel Service(频道服务) 对于较大群 为每个聊天的Thread增加一个Channel信息 
1. 用户上线时，Web Server (message service) 找到用户所属的频道(群)，并通知 Channel Service 完成订阅 Channel就知道哪些频道里有哪些用户还活着
2. 用户如果断线了，Push Service 会知道用户掉线了，通知 Channel Service 从所属的频道里移除
3. Message Service 收到用户发的信息之后  根据thread id找到对应的channel
4. 把发消息的请求发送给 Channel Service  原来发500条消息变成发1条消息
5. Channel Service 找到当前在线的用户
6. 然后发给 Push Service 把消息 Push 出去
本质利用了订阅和push service

Q: Channel Service 中的数据是什么结构?
A: key-value 的结构。key 为 channel name，可以是一个字符串比如 “#personal::user_1”。value是一个set 代表哪些人订阅到了这个 channel 下。
Q: Channel Service 用什么数据存储?
A: 根据上面所提到的 key-value 结构以及 value 需要是一个 set，Redis 是一个很好的选择。 
Q: 如何知道一个用户该订阅到哪些 Channels?
A: 首先用户需要订阅自己的 personal channel，如 #personal::user_1，与该用户有关的私聊信息都在这 个 channel 里发送。小于一定人数的群聊可以依然通过 personal channel 推送，超过一定人数的群聊， 可以采用 lazy subscribe 的方式，在用户打开 APP 且群处于比较靠前的位置的时候才订阅，用户没有主 动订阅的群聊靠 Poll 的模式获取最新消息。

拓展问题1:多机登录 multiple session
在 session 中记录用户的客户端信息
用户尝试从新的客户端登录时 如从手机登陆时，查询是否已经有其他手机处于登陆状态 如果没有，则创建新的 session 如果有，将对应的 session 设为 expire 或者删除，并发送 push notification 让已经登录的手机 logout

拓展问题2:如何支持用户在线状态显示? Pull (heartbeat)
使用数据库存储 online status 的信息 <user, last_updated_at, client_info>
----------






Alex Xu Chapter 12 Design a chat system

Candidate: What kind of chat app shall we design? 1 on 1 or group based? 
Interviewer: It should support both 1 on 1 and group chat.

Candidate: Is this a mobile app? Or a web app? Or both? 
Interviewer: Both.

Candidate: What is the scale of this app? A startup app or massive scale? 
Interviewer: It should support 50 million daily active users (DAU).

Candidate: For group chat, what is the group member limit? 
Interviewer: A maximum of 100 people

Candidate: What features are important for the chat app? Can it support attachment? 
Interviewer: 1 on 1 chat, group chat, online indicator. The system only supports text messages.

Candidate: Is there a message size limit?
Interviewer: Yes, text length should be less than 100,000 characters long.

Candidate: Is end-to-end encryption required?
Interviewer: Not required for now but we will discuss that if time allows.

Candidate: How long shall we store the chat history? 
Interviewer: Forever.


high level design
client use http protocol
server use polling, long polling, websocket

Long polling has a few drawbacks:
• Sender and receiver may not connect to the same chat server. HTTP based servers are usually stateless. If you use round robin for load balancing, the server that receives the message might not have 
	a long-polling connection with the client who receives the message.
• A server has no good way to tell if a client is disconnected.
• It is inefficient. If a user does not chat much, long polling still makes periodic connections after timeouts.

Websocket
WebSocket connection is initiated by the client. It is bi-directional and persistent. It starts its life as a HTTP connection and could be “upgraded” via some well-defined handshake to a WebSocket connection. 
Through this persistent connection, a server could send updates to a client

the client maintains a persistent WebSocket connection to a chat server for real-time messaging.
• Chat servers facilitate message sending/receiving.
• Presence servers manage online/offline status.
• API servers handle everything including user login, signup, change profile, etc.
• Notification servers send push notifications.
• Finally, the key-value store is used to store chat history. When an offline user comes online, she will see all her previous chat history.

Storage
relational databases or NoSQL databases ?
Two types of data exist in a typical chat system. The first is generic data, such as user profile, setting, user friends list. These data are stored in robust and reliable relational databases. 
Replication and sharding are common techniques to satisfy availability and scalability requirements.

The second is unique to chat systems: chat history data
• The amount of data is enormous for chat systems. A previous study [2] reveals that Facebook messenger and Whatsapp process 60 billion messages a day.
• Only recent chats are accessed frequently. Users do not usually look up for old chats.
• Although very recent chat history is viewed in most cases, users might use features that require random access of data, such as search, view your mentions, jump to specific messages, etc. These cases should be supported by the data access layer.
• The read to write ratio is about 1:1 for 1 on 1 chat apps.

We recommend key-value stores for the following reasons:
• Key-value stores allow easy horizontal scaling.
• Key-value stores provide very low latency to access data.
• Relational databases do not handle long tail [3] of data well. When the indexes grow large, random access is expensive.
• Key-value stores are adopted by other proven reliable chat applications. For example, both Facebook messenger and Discord use key-value stores. Facebook messenger uses HBase [4], and Discord uses Cassandra [5].

Data Models
message 										group_message
message_id  	bigint 							channel_id 		bigint
message_from 	bigint 							message_id 		bigint
message_to 		bigint 							user_id 		bigint
content 		text 							content 		text
created_at 		timestamp 						created_at  	timestamp


deep dive
Service discovery
The primary role of service discovery is to recommend the best chat server for a client based on the criteria like geographical location, server capacity,
1. User A tries to log in to the app.
2. The load balancer sends the login request to API servers.
3. After the backend authenticates the user, service discovery finds the best chat server for User A. In this example, server 2 is chosen and the server info is returned back to User A.
4. User A connects to chat server 2 through WebSocket.

Message flows
1 on 1 chat flow
1. User A sends a chat message to Chat server 1.
2. Chat server 1 obtains a message ID from the ID generator.
3. Chat server 1 sends the message to the message sync queue.
4. The message is stored in a key-value store.
5.a. If User B is online, the message is forwarded to Chat server 2 where User B is connected.
5.b. If User B is offline, a push notification is sent from push notification (PN) servers.
6. Chat server 2 forwards the message to User B. There is a persistent WebSocket connection between User B and Chat server 2.

Message synchronization across multiple devices
Each device maintains a variable called cur_max_message_id, which keeps track of the latest message ID on the device. Messages that satisfy the following two conditions are considered as news messages:
• The recipient ID is equal to the currently logged-in user ID.
• Message ID in the key-value store is larger than cur_max_message_id .
With distinct cur_max_message_id on each device, message synchronization is easy as each device can get new messages from the KV store.

Small group chat flow
Assume there are 3 members in the group (User A, User B and user C). First, the message from User A is copied to each group member’s message sync queue: one for User B and the second for User C. 
You can think of the message sync queue as an inbox for a recipien

Online presence
user login
user logout
user disconnection
online statua fanout




























